---
layout: post
title: "Memory Game"
permalink: /javascript/project/memory
---

// CSS styling 
<style>
    .memoryCanvas { 
        border: 10px solid #000;
        width: 100%;
        height: auto;
    }
    
    h2 {
        text-align: center;
        margin-top: 20px;
    }
</style>

// HTML content
<h2>Memory Game</h2>
<p>Score: <span class="score"></span></p>
<p>Attempts: <span class="attempts"></span></p>
<p>High score: <span class="highscore"></span> <button class="resetHigh">Reset</button></p>
<p>Time: <span class="time">0.00</span> s</p>
<p>Best time: <span class="besttime">--</span> s <button class="resetBest">Reset</button></p>
<div class="leaderboardContainer">
    <h3>Leaderboard (Top 10)</h3>
    <ol class="leaderboard"></ol>
    <button class="resetLeaderboard">Reset Leaderboard</button>
</div>
<div class="container">
    <canvas class="memoryCanvas" id="memoryCanvas" width="600" height="400"></canvas>
</div>

<script>
if (window.trustedTypes && !trustedTypes.createPolicy('default')) {
  trustedTypes.createPolicy('default', {
    createHTML: s => s,
    createScript: s => s,
    createScriptURL: s => s
  });
}
</script>

<script>
    // Get canvas and context for drawing
    const memCanvas = document.getElementById('memoryCanvas');
    const memCtx = memCanvas.getContext('2d');

    // Game state variables
    let clicks = 0; // Tracks number of clicks in current turn
    let revealedCells = []; // Stores currently revealed cells [{col, row, emoji}]
    let matchedCells = []; // Stores matched cells [{col, row}]
    const scoreDisplay = document.querySelector('.score');
    const attemptsDisplay = document.querySelector('.attempts');
    const highScoreDisplay = document.querySelector('.highscore');
    const timeDisplay = document.querySelector('.time');
    const bestTimeDisplay = document.querySelector('.besttime');
    const leaderboardList = document.querySelector('.leaderboard');
    let score = 0; // Player's score
    let attempts = 0; // Number of attempts made
    // Load high score from localStorage (safe fallback)
    let highScore = 0;
    try {
        const stored = localStorage.getItem('memoryHighScore');
        highScore = Number.parseInt(stored, 10);
        if (Number.isNaN(highScore)) highScore = 0;
    } catch (e) {
        highScore = 0;
    }
    highScoreDisplay.textContent = highScore;
    // Timer state
    let startTime = null;
    let timerInterval = null;
    let bestTime = null;
    try {
        const storedBest = localStorage.getItem('memoryBestTime');
        bestTime = storedBest !== null ? Number.parseFloat(storedBest) : null;
        if (bestTime !== null && Number.isNaN(bestTime)) bestTime = null;
    } catch (e) { bestTime = null; }
    bestTimeDisplay.textContent = bestTime !== null ? bestTime.toFixed(2) : '--';
    // Render leaderboard (top 10 times, with name and date)
    function renderLeaderboard() {
        try {
            const raw = JSON.parse(localStorage.getItem('memoryLeaderboard') || '[]');
            // Normalize entries to objects {time, name, date}
            const list = (Array.isArray(raw) ? raw : []).map(item => {
                if (typeof item === 'number') return {time: item, name: '---', date: null};
                if (item && typeof item === 'object') return {time: Number(item.time), name: item.name || '---', date: item.date || null};
                return null;
            }).filter(Boolean).sort((a, b) => a.time - b.time);

            leaderboardList.innerHTML = '';
            if (list.length === 0) {
                leaderboardList.innerHTML = '<li>No records</li>';
                return;
            }
            for (let i = 0; i < Math.min(10, list.length); i++) {
                const entry = list[i];
                const li = document.createElement('li');
                const datePart = entry.date ? (' - ' + entry.date) : '';
                li.textContent = (entry.name || '---') + ' - ' + entry.time.toFixed(2) + ' s' + datePart;
                leaderboardList.appendChild(li);
            }
        } catch (e) {
            leaderboardList.innerHTML = '<li>Error loading</li>';
        }
    }
    renderLeaderboard();
    scoreDisplay.textContent = score;
    attemptsDisplay.textContent = attempts;

//Track attempts, score, etc.
attemptsDisplay.textContent = attempts;

//Define grid size once
const GRID_COLS = 6;
const GRID_ROWS = 6;

//Get canvas + context
const memCanvas = document.getElementById('memoryCanvas');
const memCtx = memCanvas.getContext('2d');

// Now call the function to actually draw the grid
drawGrid(GRID_COLS, GRID_ROWS);
    // Draws the grid lines on the canvas
function drawGrid(cols, rows) {
    memCtx.strokeStyle = '#000';
    memCtx.lineWidth = 2; // thinner looks cleaner
    const cellWidth = memCanvas.width / cols;
    const cellHeight = memCanvas.height / rows;
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            memCtx.strokeRect(col * cellWidth, row * cellHeight, cellWidth, cellHeight);
        }
    }
}

    // Draws all emojis on the grid (used for initial reveal)
    function drawEmojis(cols, rows, emojis) {
        const cellWidth = memCanvas.width / cols;
        const cellHeight = memCanvas.height / rows;
        memCtx.font = `${Math.floor(Math.min(cellWidth, cellHeight) * 0.6)}px serif`;
        memCtx.textAlign = "center";
        memCtx.textBaseline = "middle";

        let emojiIndex = 0;
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const x = col * cellWidth + cellWidth / 2;
                const y = row * cellHeight + cellHeight / 2;
                const emoji = emojis[emojiIndex % emojis.length];
                memCtx.fillText(emoji, x, y);
                emojiIndex++;
            }
        }
    }

// Draw the grid immediately
    drawGrid(GRID_COLS, GRID_ROWS); // Draw the grid

    // Prepare emoji pairs and shuffle
    const baseEmojis = [
  "âšœï¸", "ðŸŽ‰", "ðŸµï¸", "ðŸŒº", "ðŸŒŸ", "ðŸª‰", "â˜€ï¸", "ðŸ¦„", "ðŸ’",
  "ðŸ’¥", "ðŸ€", "ðŸ§©", "ðŸŽˆ", "ðŸ•Šï¸", "ðŸŽ®", "ðŸ§ ", "ðŸŒŒ", "ðŸŽ­"
];
const emojiList = [...baseEmojis, ...baseEmojis]; // 36 total
shuffle(emojiList);

    // Shuffle the emoji list so pairs are random
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    // Show all emojis for 3 seconds, then hide them
    drawEmojis(GRID_COLS, GRID_ROWS, emojiList);
    setTimeout(() => hideEmojis(GRID_COLS, GRID_ROWS), 3000);

    // --- Helper functions ---

    // Covers all cells except matched ones with a gray rectangle
    function hideEmojis(cols, rows) {
        const cellWidth = memCanvas.width / cols;
        const cellHeight = memCanvas.height / rows;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Only hide if not matched
                if (!matchedCells.some(cell => cell.col === col && cell.row === row)) {
                    memCtx.fillStyle = '#CCCCCC';
                    memCtx.fillRect(col * cellWidth + 5, row * cellHeight + 5, cellWidth - 10, cellHeight - 10);
                }
            }
        }
    }

    // Reveals the emoji at a specific cell
    function revealEmojiAt(col, row, emojis, cols, rows) {
    const cellWidth = memCanvas.width / cols;
    const cellHeight = memCanvas.height / rows;
    const x = col * cellWidth + cellWidth / 2;
    const y = row * cellHeight + cellHeight / 2;
    const emojiIndex = row * cols + col;
    const emoji = emojis[emojiIndex];

    memCtx.fillStyle = '#FFFFFF';
    memCtx.fillRect(col * cellWidth + 5, row * cellHeight + 5, cellWidth - 10, cellHeight - 10);
    memCtx.fillStyle = '#000000';
    memCtx.fillText(emoji, x, y);

    return emoji;
}

// --- Click handler ---
memCanvas.addEventListener('click', (event) => {
    console.log('canvas click fired');

    // Donâ€™t allow more than 2 revealed at once
    if (revealedCells.length >= 2) return;

    // Scale mouse coords to canvas resolution
    const rect = memCanvas.getBoundingClientRect();
    const scaleX = memCanvas.width / rect.width;
    const scaleY = memCanvas.height / rect.height;
    const x = (event.clientX - rect.left) * scaleX;
    const y = (event.clientY - rect.top) * scaleY;

    // Map to grid cell
    const cols = col = Math.floor(x / (memCanvas.width / GRID_COLS));
    const rows = row = Math.floor(y / (memCanvas.height / GRID_ROWS));
    const emojiIndex = row * GRID_COLS + col;

    // âœ… Now call revealEmojiAt with valid col/row
   // const emoji = revealEmojiAt(col, row, emojiList, GRID_COLS, GRID_ROWS);

   // revealedCells.push({ col, row, emoji, emojiIndex });
    // clicks += 1;


    // Prevent clicking already matched or already revealed cell
    if (
        matchedCells.some(cell => cell.col === col && cell.row === row) ||
        revealedCells.some(cell => cell.col === col && cell.row === row)
    ) {
        return;
    }

    console.log(`Click accepted at cell [${row}, ${col}]`);

    // Reveal the clicked emoji
   const emoji = revealEmojiAt(col, row, emojiList, GRID_COLS, GRID_ROWS);
    revealedCells.push({col, row, emoji, emojiIndex });
    clicks += 1;

    // Start timer on first valid click
    if (startTime === null) {
        startTime = Date.now();
        timerInterval = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            timeDisplay.textContent = elapsed.toFixed(2);
        }, 100);
    }

    // If two emojis are revealed, check for a match
    if (revealedCells.length === 2) {
        attempts += 1;
        attemptsDisplay.textContent = attempts;

        if (revealedCells[0].emoji === revealedCells[1].emoji) {
            // Matched
            score += 1;
            scoreDisplay.textContent = score;
            if (score > highScore) {
                highScore = score;
                try { localStorage.setItem('memoryHighScore', String(highScore)); } catch (e) {}
                highScoreDisplay.textContent = highScore;
            }
            matchedCells.push(revealedCells[0], revealedCells[1]);
            revealedCells = [];
            clicks = 0;
        } else {
            // Not matched, hide after short delay
            setTimeout(() => {
                hideEmojis(GRID_COLS, GRID_ROWS);
                revealedCells = [];
                clicks = 0;
            }, 800);
        }
    }

    // Victory condition: all 18 pairs matched
    if (score === 18) {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        const finalTime = startTime ? (Date.now() - startTime) / 1000 : 0;
        timeDisplay.textContent = finalTime.toFixed(2);
        if (bestTime === null || finalTime < bestTime) {
            bestTime = finalTime;
            try { localStorage.setItem('memoryBestTime', String(bestTime)); } catch (e) {}
            bestTimeDisplay.textContent = bestTime.toFixed(2);
        }
        let playerName = '';
        try {
            const raw = prompt('You set a top time! Enter your name/initials (1-10 chars):', '');
            if (raw !== null) playerName = raw.trim().substring(0, 10);
        } catch (e) { playerName = ''; }
        if (!playerName) playerName = '---';
        const dateStr = new Date().toLocaleDateString();
        try {
            let lb = JSON.parse(localStorage.getItem('memoryLeaderboard') || '[]');
            if (!Array.isArray(lb)) lb = [];
            lb.push({time: finalTime, name: playerName, date: dateStr});
            lb.sort((a, b) => Number(a.time) - Number(b.time));
            while (lb.length > 10) lb.pop();
            localStorage.setItem('memoryLeaderboard', JSON.stringify(lb));
        } catch (e) {}
        renderLeaderboard();
        alert("Congratulations! You've matched all pairs! Time: " + finalTime.toFixed(2) + "s");
        location.reload();
    }
});

    // Draw all emojis at the start (for initial reveal)
    drawEmojis(6, 6, emojiList);

    // Reset high score button handler
    document.querySelector('.resetHigh').addEventListener('click', () => {
        try { localStorage.removeItem('memoryHighScore'); } catch (e) {}
        highScore = 0;
        highScoreDisplay.textContent = 0;
    });

    // Reset best time handler
    document.querySelector('.resetBest').addEventListener('click', () => {
        try { localStorage.removeItem('memoryBestTime'); } catch (e) {}
        bestTime = null;
        bestTimeDisplay.textContent = '--';
    });

    // Reset leaderboard handler
    document.querySelector('.resetLeaderboard').addEventListener('click', () => {
        try { localStorage.removeItem('memoryLeaderboard'); } catch (e) {}
        renderLeaderboard();
    });

    // Helper: clear any running timer when reloading or navigating away
    window.addEventListener('beforeunload', () => {
        if (timerInterval) clearInterval(timerInterval);
    });
</script>