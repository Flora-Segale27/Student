---
layout: post
title: "Memory Game"
permalink: /javascript/project/memory
---

<style>
    .memoryCanvas { 
        border: 10px solid #000;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
    
    h2 {
        text-align: center;
        margin-top: 20px;
    }
</style>

<h2>Memory Game</h2>
<p>Score: <span class="score"></span></p>
<p>Attempts: <span class="attempts"></span></p>
<p>High score: <span class="highscore"></span> <button class="resetHigh">Reset</button></p>
<p>Time: <span class="time">0.00</span> s</p>
<p>Best time: <span class="besttime">--</span> s <button class="resetBest">Reset</button></p>
<div class="leaderboardContainer">
    <h3>Leaderboard (Top 10)</h3>
    <ol class="leaderboard"></ol>
    <button class="resetLeaderboard">Reset Leaderboard</button>
</div>
<div class="container">
    <canvas class="memoryCanvas" id="memoryCanvas" width="600" height="400"></canvas>
</div>

<script>
if (window.trustedTypes && !trustedTypes.createPolicy('default')) {
  trustedTypes.createPolicy('default', {
    createHTML: s => s,
    createScript: s => s,
    createScriptURL: s => s
  });
}
</script>

<script>
    // Get canvas and context for drawing
    const memCanvas = document.getElementById('memoryCanvas');
    const memCtx = memCanvas.getContext('2d');

    // Game state variables
    let clicks = 0; // Tracks number of clicks in current turn
    let revealedCells = []; // Stores currently revealed cells [{col, row, emoji}]
    let matchedCells = []; // Stores matched cells [{col, row}]
    const scoreDisplay = document.querySelector('.score');
    const attemptsDisplay = document.querySelector('.attempts');
    const highScoreDisplay = document.querySelector('.highscore');
    const timeDisplay = document.querySelector('.time');
    const bestTimeDisplay = document.querySelector('.besttime');
    const leaderboardList = document.querySelector('.leaderboard');
    let score = 0; // Player's score
    let attempts = 0; // Number of attempts made
    // Load high score from localStorage (safe fallback)
    let highScore = 0;
    try {
        const stored = localStorage.getItem('memoryHighScore');
        highScore = Number.parseInt(stored, 10);
        if (Number.isNaN(highScore)) highScore = 0;
    } catch (e) {
        highScore = 0;
    }
    highScoreDisplay.textContent = highScore;
    // Timer state
    let startTime = null;
    let timerInterval = null;
    let bestTime = null;
    try {
        const storedBest = localStorage.getItem('memoryBestTime');
        bestTime = storedBest !== null ? Number.parseFloat(storedBest) : null;
        if (bestTime !== null && Number.isNaN(bestTime)) bestTime = null;
    } catch (e) { bestTime = null; }
    bestTimeDisplay.textContent = bestTime !== null ? bestTime.toFixed(2) : '--';
    // Render leaderboard (top 10 times, with name and date)
    function renderLeaderboard() {
        try {
            const raw = JSON.parse(localStorage.getItem('memoryLeaderboard') || '[]');
            // Normalize entries to objects {time, name, date}
            const list = (Array.isArray(raw) ? raw : []).map(item => {
                if (typeof item === 'number') return {time: item, name: '---', date: null};
                if (item && typeof item === 'object') return {time: Number(item.time), name: item.name || '---', date: item.date || null};
                return null;
            }).filter(Boolean).sort((a, b) => a.time - b.time);

            leaderboardList.innerHTML = '';
            if (list.length === 0) {
                leaderboardList.innerHTML = '<li>No records</li>';
                return;
            }
            for (let i = 0; i < Math.min(10, list.length); i++) {
                const entry = list[i];
                const li = document.createElement('li');
                const datePart = entry.date ? (' - ' + entry.date) : '';
                li.textContent = (entry.name || '---') + ' - ' + entry.time.toFixed(2) + ' s' + datePart;
                leaderboardList.appendChild(li);
            }
        } catch (e) {
            leaderboardList.innerHTML = '<li>Error loading</li>';
        }
    }
    renderLeaderboard();
    scoreDisplay.textContent = score;
    attemptsDisplay.textContent = attempts;

    // Draws the grid lines on the canvas
    function drawGrid(cols, rows) {
        memCtx.strokeStyle = '#000';
        memCtx.lineWidth = 10;

        canvasCol = cols;
        canvasRow = rows;

        const canvasWidth = memCanvas.width;
        const canvasHeight = memCanvas.height;

        // Draw vertical lines
        for (let x = 0; x <= canvasWidth; x += canvasWidth / canvasCol) {
            memCtx.beginPath();
            memCtx.moveTo(x, 0);
            memCtx.lineTo(x, canvasHeight);
            memCtx.stroke();
        }
        // Draw horizontal lines
        for (let y = 0; y <= canvasHeight; y += canvasHeight / canvasRow) {
            memCtx.beginPath();
            memCtx.moveTo(0, y);
            memCtx.lineTo(canvasWidth, y);
            memCtx.stroke();
        }
    }

    // Draws all emojis on the grid (used for initial reveal)
    function drawEmojis(cols, rows, emojis) {
        const cellWidth = memCanvas.width / cols;
        const cellHeight = memCanvas.height / rows;
        memCtx.font = `${Math.floor(Math.min(cellWidth, cellHeight) * 0.6)}px serif`;
        memCtx.textAlign = "center";
        memCtx.textBaseline = "middle";

        let emojiIndex = 0;
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const x = col * cellWidth + cellWidth / 2;
                const y = row * cellHeight + cellHeight / 2;
                const emoji = emojis[emojiIndex % emojis.length];
                memCtx.fillText(emoji, x, y);
                emojiIndex++;
            }
        }
    }

    drawGrid(5, 5); // Draw the grid

    // Prepare emoji pairs and shuffle
    const baseEmojis = [
        "âšœï¸", "ðŸŽ‰", "ðŸµï¸", "ðŸŒº", "ðŸŒŸ", "ðŸª‰", "â˜€ï¸", "ðŸ¦„", "ðŸ’", "ðŸ’¥"
    ];
    // Duplicate emojis for pairs (20 cells, 10 pairs)
    const emojiList = [...baseEmojis, ...baseEmojis];

    // Shuffle the emoji list so pairs are random
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
    shuffle(emojiList);

    // Covers all cells except matched ones with a gray rectangle
    function hideEmojis(cols, rows) {
        const cellWidth = memCanvas.width / cols;
        const cellHeight = memCanvas.height / rows;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Only hide if not matched
                if (!matchedCells.some(cell => cell.col === col && cell.row === row)) {
                    memCtx.fillStyle = '#CCCCCC';
                    memCtx.fillRect(col * cellWidth + 5, row * cellHeight + 5, cellWidth - 10, cellHeight - 10);
                }
            }
        }
    }
    // Show all emojis for 3 seconds, then hide them
    setTimeout(() => hideEmojis(5, 5), 3000);

    // Reveals the emoji at a specific cell
    function revealEmojiAt(col, row, emojis) {
        const cellWidth = memCanvas.width / 4;
        const cellHeight = memCanvas.height / 4;
        const x = col * cellWidth + cellWidth / 2;
        const y = row * cellHeight + cellHeight / 2;
        const emojiIndex = row * 4 + col;
        const emoji = emojis[emojiIndex];

        // Draw white background and emoji
        memCtx.fillStyle = '#FFFFFF';
        memCtx.fillRect(col * cellWidth + 5, row * cellHeight + 5, cellWidth - 10, cellHeight - 10);
        memCtx.fillStyle = '#000000';
        memCtx.fillText(emoji, x, y);
        return emoji;
    }

    // Handles user clicks on the canvas
    memCanvas.addEventListener('click', (event) => {
        // Limit to two revealed cells at a time
        if (revealedCells.length >= 2) {
            // Ignore clicks until current pair is processed
            return;
        }

        // Get mouse position relative to canvas
        const rect = memCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // Calculate which cell was clicked
        const col = Math.floor(x / (memCanvas.width / 4));
        const row = Math.floor(y / (memCanvas.height / 4));
        const emojiIndex = row * 4 + col;

        // Prevent clicking already matched or already revealed cell
        if (
            matchedCells.some(cell => cell.col === col && cell.row === row) ||
            revealedCells.some(cell => cell.col === col && cell.row === row)
        ) {
            return;
        }

        // Reveal the clicked emoji
        const emoji = revealEmojiAt(col, row, emojiList);
        revealedCells.push({col, row, emoji, emojiIndex});
        clicks += 1;

        // Start timer on first valid click
        if (startTime === null) {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                timeDisplay.textContent = elapsed.toFixed(2);
            }, 100);
        }

        // If two emojis are revealed, check for a match
        if (revealedCells.length === 2) {
            attempts += 1;
            attemptsDisplay.textContent = attempts;
            if (revealedCells[0].emoji === revealedCells[1].emoji) {
                // Matched, keep revealed and update score
                score += 1;
                scoreDisplay.textContent = score;
                // Update high score if necessary and persist it
                if (score > highScore) {
                    highScore = score;
                    try { localStorage.setItem('memoryHighScore', String(highScore)); } catch (e) {}
                    highScoreDisplay.textContent = highScore;
                }
                matchedCells.push(revealedCells[0], revealedCells[1]);
                revealedCells = [];
                clicks = 0;
            } else {
                // Not matched, hide after short delay
                setTimeout(() => {
                    hideEmojis(4, 4);
                    revealedCells = [];
                    clicks = 0;
                }, 800);
            }
        }
        if(score == 8) {
            // Stop timer and handle best time
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
            const finalTime = startTime ? (Date.now() - startTime) / 1000 : 0;
            timeDisplay.textContent = finalTime.toFixed(2);
            if (bestTime === null || finalTime < bestTime) {
                bestTime = finalTime;
                try { localStorage.setItem('memoryBestTime', String(bestTime)); } catch (e) {}
                bestTimeDisplay.textContent = bestTime.toFixed(2);
            }
            // Ask for player initials/name (1-10 chars)
            let playerName = '';
            try {
                const raw = prompt('You set a top time! Enter your name/initials (1-10 chars):', '');
                if (raw !== null) playerName = raw.trim().substring(0, 10);
            } catch (e) { playerName = ''; }
            if (!playerName) playerName = '---';
            const dateStr = new Date().toLocaleDateString();
            // Update leaderboard (store objects {time, name, date}) and keep top 10
            try {
                let lb = JSON.parse(localStorage.getItem('memoryLeaderboard') || '[]');
                if (!Array.isArray(lb)) lb = [];
                lb.push({time: finalTime, name: playerName, date: dateStr});
                lb.sort((a, b) => Number(a.time) - Number(b.time));
                while (lb.length > 10) lb.pop();
                localStorage.setItem('memoryLeaderboard', JSON.stringify(lb));
            } catch (e) {}
            renderLeaderboard();
            alert("Congratulations! You've matched all pairs! Time: " + finalTime.toFixed(2) + "s");
            // reload to restart the game
            location.reload();
        }
    });

    // Draw all emojis at the start (for initial reveal)
    drawEmojis(4, 4, emojiList);

    // Reset high score button handler
    document.querySelector('.resetHigh').addEventListener('click', () => {
        try { localStorage.removeItem('memoryHighScore'); } catch (e) {}
        highScore = 0;
        highScoreDisplay.textContent = 0;
    });

    // Reset best time handler
    document.querySelector('.resetBest').addEventListener('click', () => {
        try { localStorage.removeItem('memoryBestTime'); } catch (e) {}
        bestTime = null;
        bestTimeDisplay.textContent = '--';
    });

    // Reset leaderboard handler
    document.querySelector('.resetLeaderboard').addEventListener('click', () => {
        try { localStorage.removeItem('memoryLeaderboard'); } catch (e) {}
        renderLeaderboard();
    });

    // Helper: clear any running timer when reloading or navigating away
    window.addEventListener('beforeunload', () => {
        if (timerInterval) clearInterval(timerInterval);
    });
</script>